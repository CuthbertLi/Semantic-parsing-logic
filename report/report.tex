\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx, fancyhdr, amsmath, amssymb, amsthm, subfig}
\usepackage{indentfirst}
\usepackage{pdfpages}
\usepackage{dirtree}
\usepackage{lastpage, hyperref}
% \usepackage{hyperref, url}

% \pagestyle{fancy}
% \fancyhf{}
% \rhead{Page \thepage\ of \pageref{LastPage}}
\title{Semantic Parsing for First-order Logic}
\author{
	Li Dinghong\\
	SIST, Shanghaitech University\\
	27663262\\
	\{lidh1, liujd, wudi\}@shanghaitech.edu.cn
}

\begin{document}
% abstract and beginnings
{
	\newpage
	\maketitle

	\textbf{Abstract}-{In this paper, we present a generic model for semantic parsing. }

	\vspace{5pt}
	\textbf{\emph{Keywords:}} {}

	\tableofcontents
}

\section{Introduction}{
	\subsection{Background and Motivating Applications}{
		The Goal of semantic parsing is to formalize natural languages. That is, translating texts in natural languages into formal languges, like first-order logic (FOL) or higher-order logic. 

		Semantic parsing can be applied in a wide range of fields both in computer science and outside computer science. Computer security of a software, for instance, cannot be confirmed until it is studied formally and mathematically. Empirical methods like fuzzing are not so reliable because they lack solid foundations. Thus, semantic parsing is necessary. 

		Formal verification of programming languages also require to formalize user manuals or official guides, which are typically written in natural languages. Most of these tasks are done by hand now. This is tedious and erroneous. 

		Semantic parsing can also help to prove mathematical theorems as well as to check their proofs automatically. Output of a semantic parser is in logical forms, so it can be accepted by computers. Computers can then finish later tasks by inference. 
	}

	\subsection{}{}

	\subsection{Related Works and Our Contributions}{
		Thanks to parsing trees, our model is highly generic. We can easily reuse it for a different natural language by simply defining new rules. 

		We succeed to implement a binding and scoping structures based on parsing trees. 
	}
}

\section{Methods}{
	\subsection{Grammars and Parsing Tree}{
		According to Chomsky hierarchy, formal grammars can be classified as regular grammar, context-free grammar, context-sensitive grammar and recursive enumerable grammar. 

		Context-sensitive grammar is computationally intractable and recursive enumerable grammar is even undecideable, although more expressive and more powerful. Besides, regular grammar is obviously too restrictive. Therefore, we can choose either context-free grammar or one of its subset, dependency grammar. 

		We first consider dependency grammar, since dependency trees seem to preserve enough information we need. 
	}

	\subsection{Recursive Definition of FOL}{}
}

\section{Two-step Semantic Parsing}{
	\subsection{Lexical Analysis and Syntax Analysis}{}

	\subsection{Parsing Tree Traversal}{}
}

\section{Generation of FOL}{}

\section{Results}{}

\section{Conclusion}{}

\bibliographystyle{unsrt}
\bibliography{report}
\citation

\end{document}